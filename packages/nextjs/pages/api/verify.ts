import DaiContract from "../../../hardhat/deployments/localhost/DAI.json";
import ZupassUserRegistryContract from "../../../hardhat/deployments/localhost/ZupassUserRegistry.json";
import { ZKEdDSAEventTicketPCDPackage } from "@pcd/zk-eddsa-event-ticket-pcd";
import { NextApiRequest, NextApiResponse } from "next";
import { hexToBigInt } from "viem";
import { createPublicClient, createWalletClient, http, isAddress, parseEther } from "viem";
import { hardhat } from "viem/chains";

const localWalletClient = createWalletClient({
  chain: hardhat,
  transport: http(),
});

const client = createPublicClient({
  chain: hardhat,
  transport: http(),
});

const accounts = await localWalletClient.getAddresses();

const gasDrop = parseEther("0.0015");
const daiDrop = parseEther("10");

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const pcd = await ZKEdDSAEventTicketPCDPackage.deserialize(req.body.pcd);
  const address = req.body.address;
  const semaphoreId = pcd.claim.partialTicket.attendeeSemaphoreId;

  // ## Validations
  if (!isAddress(address)) {
    return res.status(401).send("Invalid address");
  }

  if (!(await ZKEdDSAEventTicketPCDPackage.verify(pcd))) {
    console.error(`[ERROR] ZK ticket PCD is not valid`);

    return res.status(401).send("ZK ticket PCD is not valid");
  }

  if ("1ebfb986fbac5113f8e2c72286fe9362f8e7d211dbc68227a468d7b919e75003" != pcd.claim.signer[0]) {
    console.error(`[ERROR] PCD is not signed by Zupass`);
    return res.status(401).send("PCD is not signed by Zupass");
  }

  if (!pcd.claim.partialTicket.isConsumed) {
    console.error(`[ERROR Frontend] Ticket not consumed`);
    return res.status(401).send("Ticket not consumed");
  }

  // TODO: Use real nonce generated by the server
  if (pcd.claim.watermark.toString() !== hexToBigInt(address as `0x${string}`).toString()) {
    console.error(`[ERROR] PCD watermark doesn't match`);
    return res.status(401).send("PCD watermark doesn't match");
  }

  // TODO: Check that the event id is the one we expect

  const isVerified = await client.readContract({
    address: ZupassUserRegistryContract.address,
    abi: ZupassUserRegistryContract.abi,
    functionName: "isVerifiedSemaphoreId",
    args: [semaphoreId],
  });

  if (isVerified) {
    console.error(`[ERROR] User already registred`);
    // return res.status(401).send("User already registred");
    return res.status(200).json({
        error: true,
        pcd:pcd,
        message: `Usuario ya registrado!`,
      });
  }

  // ## Actions
  const registryResult = await localWalletClient.writeContract({
    account: accounts[0],
    address: ZupassUserRegistryContract.address,
    abi: ZupassUserRegistryContract.abi,
    functionName: "addUser",
    args: [address, semaphoreId],
  });

  // Send ETH to the user. This is just for testing purposes, and it could be any backend action.
  await localWalletClient.sendTransaction({
    to: req.body.address,
    value: gasDrop,
    account: accounts[0],
  });

  await localWalletClient.writeContract({
    account: accounts[0],
    address: DaiContract.address,
    abi: DaiContract.abi,
    functionName: "transfer",
    args: [address, daiDrop],
  });

  return res.status(200).json({
    message: `ðŸŽ‰ PCD verified! You can vote now! Also 0.0015 ETH and 10 DAIs have been sent to ${address}!`,
    txHash: registryResult,
  });
}
